---
sidebar_position: 4
title: CI/CD Usage
description: Use CX Linux in continuous integration and deployment pipelines. GitHub Actions, GitLab CI, Jenkins, and more.
keywords: [ci, cd, continuous integration, deployment, github actions, gitlab ci]
---

# CI/CD Usage

This tutorial covers using CX Linux in CI/CD pipelines. Automate installations, configurations, and deployments with natural language commands.

## Time Required

- Basic setup: 15 minutes
- Full pipeline: 30-60 minutes

## Prerequisites

- CI/CD platform access
- Repository with code
- CX Linux installation script or pre-built image

## GitHub Actions

### Basic Setup

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install CX Linux
        run: |
          curl -fsSL https://cxlinux.com/install.sh | bash
          echo "$HOME/.cx/bin" >> $GITHUB_PATH

      - name: Setup environment
        run: cx "install all dependencies for this project"
        env:
          CX_CI: true
          CX_YES: true

      - name: Run tests
        run: cx "run the test suite"

      - name: Build
        run: cx "build for production"
```

### Using CX Linux Action

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cxlinux-ai/setup-cx@v1
        with:
          version: 'latest'

      - name: Setup and test
        run: |
          cx "install dependencies"
          cx "run tests"
        env:
          CX_CI: true
```

### Matrix Builds

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [16, 18, 20]

    steps:
      - uses: actions/checkout@v4

      - uses: cxlinux-ai/setup-cx@v1

      - name: Setup Node ${{ matrix.node }}
        run: cx "install nodejs version ${{ matrix.node }}"
        env:
          CX_CI: true

      - name: Test
        run: cx "run tests"
```

### Deploy Workflow

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cxlinux-ai/setup-cx@v1

      - name: Build
        run: cx "build docker image for production"
        env:
          CX_CI: true

      - name: Push to registry
        run: cx "push image to docker hub"
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

      - name: Deploy
        run: cx "deploy to kubernetes cluster"
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG }}
```

---

## GitLab CI

### Basic Pipeline

```yaml
# .gitlab-ci.yml
stages:
  - setup
  - test
  - build
  - deploy

variables:
  CX_CI: "true"
  CX_YES: "true"

before_script:
  - curl -fsSL https://cxlinux.com/install.sh | bash
  - export PATH="$HOME/.cx/bin:$PATH"

test:
  stage: test
  script:
    - cx "install project dependencies"
    - cx "run tests"
  artifacts:
    reports:
      junit: test-results.xml

build:
  stage: build
  script:
    - cx "build for production"
  artifacts:
    paths:
      - dist/

deploy:
  stage: deploy
  script:
    - cx "deploy to production server"
  only:
    - main
  environment:
    name: production
```

### Using CX Linux Docker Image

```yaml
# .gitlab-ci.yml
image: cxlinux-ai/cx:latest

stages:
  - test
  - deploy

test:
  stage: test
  script:
    - cx "install dependencies and run tests"

deploy:
  stage: deploy
  script:
    - cx "deploy application"
  only:
    - main
```

### Multi-Project Pipeline

```yaml
# .gitlab-ci.yml
stages:
  - test
  - trigger

test:
  stage: test
  script:
    - cx "run tests"

trigger-deploy:
  stage: trigger
  trigger:
    project: mygroup/deploy-pipeline
    branch: main
  only:
    - main
```

---

## Jenkins

### Jenkinsfile

```groovy
// Jenkinsfile
pipeline {
    agent any

    environment {
        CX_CI = 'true'
        CX_YES = 'true'
    }

    stages {
        stage('Setup CX Linux') {
            steps {
                sh 'curl -fsSL https://cxlinux.com/install.sh | bash'
                sh 'export PATH="$HOME/.cx/bin:$PATH"'
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'cx "install all project dependencies"'
            }
        }

        stage('Test') {
            steps {
                sh 'cx "run test suite"'
            }
            post {
                always {
                    junit 'test-results/*.xml'
                }
            }
        }

        stage('Build') {
            steps {
                sh 'cx "build for production"'
            }
        }

        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                sh 'cx "deploy to production"'
            }
        }
    }

    post {
        failure {
            sh 'cx "collect logs and diagnostics"'
        }
    }
}
```

### Docker Agent

```groovy
pipeline {
    agent {
        docker {
            image 'cxlinux-ai/cx:latest'
        }
    }

    stages {
        stage('Test') {
            steps {
                sh 'cx "install dependencies and run tests"'
            }
        }
    }
}
```

---

## CircleCI

### Config

```yaml
# .circleci/config.yml
version: 2.1

executors:
  cx:
    docker:
      - image: cxlinux-ai/cx:latest

jobs:
  test:
    executor: cx
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: cx "install project dependencies"
      - run:
          name: Run tests
          command: cx "run tests"
      - store_test_results:
          path: test-results

  deploy:
    executor: cx
    steps:
      - checkout
      - run:
          name: Deploy
          command: cx "deploy to production"

workflows:
  build-and-deploy:
    jobs:
      - test
      - deploy:
          requires:
            - test
          filters:
            branches:
              only: main
```

---

## Azure DevOps

### Pipeline YAML

```yaml
# azure-pipelines.yml
trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  CX_CI: 'true'
  CX_YES: 'true'

stages:
  - stage: Build
    jobs:
      - job: BuildJob
        steps:
          - script: |
              curl -fsSL https://cxlinux.com/install.sh | bash
              export PATH="$HOME/.cx/bin:$PATH"
            displayName: 'Install CX Linux'

          - script: cx "install dependencies"
            displayName: 'Install Dependencies'

          - script: cx "run tests"
            displayName: 'Run Tests'

          - script: cx "build for production"
            displayName: 'Build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathtoPublish: 'dist'
              artifactName: 'build'

  - stage: Deploy
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployJob
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - script: cx "deploy application"
                  displayName: 'Deploy'
```

---

## Environment Variables for CI

### Required Variables

```bash
# Always set in CI environments
CX_CI=true          # Enable CI mode
CX_YES=true         # Skip confirmations
CX_NONINTERACTIVE=true  # No interactive prompts
```

### Optional Variables

```bash
# Customize behavior
CX_MODE=execute     # Always execute (not dry-run)
CX_NO_COLOR=true    # Disable colored output
CX_FORMAT=json      # Machine-readable output
CX_LOG_LEVEL=warn   # Reduce log verbosity
```

### Secrets

```bash
# Never commit these - use CI secret management
CX_API_KEY=...      # If using cloud backend
DOCKER_PASSWORD=...     # For registry auth
KUBECONFIG=...          # For deployments
```

---

## Common CI Tasks

### Dependency Installation

```yaml
- run: cx "install all dependencies for this project"
```

CX Linux detects:
- `package.json` → npm/yarn
- `requirements.txt` → pip
- `Cargo.toml` → cargo
- `go.mod` → go mod

### Running Tests

```yaml
- run: cx "run tests and generate coverage report"
```

### Building

```yaml
- run: cx "build for production optimizing for size"
```

### Docker Operations

```yaml
- run: cx "build docker image tagged with git sha"
- run: cx "push image to registry"
```

### Deployment

```yaml
- run: cx "deploy to kubernetes namespace production"
```

---

## Caching

### GitHub Actions

```yaml
- uses: actions/cache@v3
  with:
    path: ~/.cx/cache
    key: cx-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      cx-${{ runner.os }}-
```

### GitLab CI

```yaml
cache:
  paths:
    - ~/.cx/cache/
    - node_modules/
```

---

## Error Handling

### Retry Logic

```yaml
# GitHub Actions
- run: cx "install dependencies"
  continue-on-error: false
  timeout-minutes: 10
```

### Diagnostics on Failure

```yaml
- run: cx "run tests"

- if: failure()
  run: cx "collect diagnostic information"

- if: failure()
  uses: actions/upload-artifact@v3
  with:
    name: diagnostics
    path: diagnostics/
```

---

## Example Complete Pipeline

### Full CI/CD with CX Linux

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  CX_CI: true
  CX_YES: true

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: cxlinux-ai/setup-cx@v1
      - run: cx "run linter and format check"

  test:
    runs-on: ubuntu-latest
    needs: lint
    strategy:
      matrix:
        node: [18, 20]
    steps:
      - uses: actions/checkout@v4
      - uses: cxlinux-ai/setup-cx@v1
      - run: cx "install nodejs ${{ matrix.node }}"
      - run: cx "install dependencies"
      - run: cx "run tests with coverage"
      - uses: codecov/codecov-action@v3

  build:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
      - uses: cxlinux-ai/setup-cx@v1
      - run: cx "build docker image"
      - run: cx "push to ghcr.io"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - uses: cxlinux-ai/setup-cx@v1
      - run: cx "deploy to staging environment"
        env:
          KUBECONFIG: ${{ secrets.STAGING_KUBECONFIG }}

  deploy-production:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: cxlinux-ai/setup-cx@v1
      - run: cx "deploy to production with rolling update"
        env:
          KUBECONFIG: ${{ secrets.PROD_KUBECONFIG }}
```

---

## Next Steps

- [Docker Integration](/docs/tutorials/docker-integration) - Container workflows
- [Server Configuration](/docs/tutorials/server-configuration) - Deployment targets
- [Environment Variables](/docs/reference/environment-variables) - CI configuration
