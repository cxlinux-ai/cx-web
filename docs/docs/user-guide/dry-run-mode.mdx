---
sidebar_position: 4
title: Dry-Run Mode
description: Preview commands before execution. Understand exactly what CX Linux will do without making changes.
keywords: [dry-run, preview, safe mode, testing, simulation]
---

# Dry-Run Mode

Dry-run mode lets you see exactly what CX Linux will do before it does anything. This is essential for learning, validating complex operations, and building confidence with CX Linux.

## Why Use Dry-Run

### Safety First

Before executing potentially impactful commands:

```bash
# See what will happen
cx --dry-run "remove all packages installed in the last week"

# Output shows:
# Would remove: package1, package2, package3
# Would free: 500MB disk space
# Would NOT affect: system packages, dependencies
```

### Learning Tool

Understand what commands translate to:

```bash
cx --dry-run "set up a secure SSH server"

# Shows you:
# 1. Would install openssh-server
# 2. Would modify /etc/ssh/sshd_config
# 3. Would disable password authentication
# 4. Would enable key-based auth only
# 5. Would restart sshd service
```

### Validation

Verify your intent was understood correctly:

```bash
cx --dry-run "update only security packages"

# Confirms CX Linux will:
# - Update: libssl, openssl, linux-image (security)
# - Skip: nodejs, nginx (not security updates)
```

## Using Dry-Run

### Command Line Flag

```bash
# Long form
cx --dry-run "your command"

# Short form
cx -n "your command"
```

### Configuration Default

Make dry-run the default mode:

```bash
# In ~/.config/cx/config.yaml
default_mode: dry-run

# Or via command
cx config set default_mode dry-run
```

Then use `--execute` to actually run:

```bash
cx --execute "install nginx"
cx -e "install nginx"
```

### Interactive Mode

During execution preview:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CX Linux will execute:                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ apt install nginx                       â”‚
â”‚ systemctl enable nginx                  â”‚
â”‚ systemctl start nginx                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [y] Execute  [n] Cancel  [d] Dry-run    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Press `d` to switch to dry-run for that command.

## Dry-Run Output

### Standard Output

```bash
cx --dry-run "install docker"
```

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 DRY RUN - No changes will be made
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“¦ Package Operations:
   â””â”€ Would install: docker-ce docker-ce-cli containerd.io

ðŸ”§ System Changes:
   â””â”€ Would add apt repository: docker-ce-stable
   â””â”€ Would add GPG key: Docker Release

âš™ï¸  Service Operations:
   â””â”€ Would enable: docker.service
   â””â”€ Would start: docker.service

ðŸ‘¤ Group Changes:
   â””â”€ Would add current user to: docker

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 To execute, run: cx --execute "install docker"
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Verbose Dry-Run

For more detail:

```bash
cx --dry-run --verbose "configure the firewall for a web server"
```

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 DRY RUN (VERBOSE) - No changes will be made
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Step 1: Check firewall status
   Command: ufw status
   Purpose: Verify current firewall configuration

Step 2: Enable firewall if not active
   Command: ufw enable
   Purpose: Activate the firewall
   Note: Will prompt for confirmation

Step 3: Allow SSH (prevent lockout)
   Command: ufw allow 22/tcp
   Purpose: Ensure SSH access is maintained

Step 4: Allow HTTP traffic
   Command: ufw allow 80/tcp
   Purpose: Enable web server access

Step 5: Allow HTTPS traffic
   Command: ufw allow 443/tcp
   Purpose: Enable secure web server access

Step 6: Reload firewall
   Command: ufw reload
   Purpose: Apply all changes

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Diff Output

For configuration changes:

```bash
cx --dry-run "optimize nginx for high traffic"
```

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 Configuration Changes Preview
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

File: /etc/nginx/nginx.conf

- worker_processes auto;
+ worker_processes 4;

- worker_connections 768;
+ worker_connections 4096;

+ # Performance optimizations
+ worker_rlimit_nofile 65535;
+ multi_accept on;
+ use epoll;

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## Common Dry-Run Scenarios

### Package Management

```bash
# System upgrades
cx --dry-run "upgrade all packages"

# Removals
cx --dry-run "remove unused packages"

# Major version upgrades
cx --dry-run "upgrade python to version 3.12"
```

### System Configuration

```bash
# Network changes
cx --dry-run "configure static IP address"

# Service modifications
cx --dry-run "set up nginx as reverse proxy"

# Security changes
cx --dry-run "harden SSH configuration"
```

### File Operations

```bash
# Permission changes
cx --dry-run "secure the /var/www directory"

# Ownership changes
cx --dry-run "set up proper ownership for web files"

# Bulk operations
cx --dry-run "clean up temporary files older than 7 days"
```

### User Management

```bash
# User creation
cx --dry-run "create deployment user with appropriate permissions"

# Permission changes
cx --dry-run "add user to docker group"

# Access modifications
cx --dry-run "configure sudo access for the dev team"
```

## Dry-Run with Explanation

Combine dry-run with explanation mode:

```bash
cx --dry-run --explain "set up automatic security updates"
```

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 DRY RUN WITH EXPLANATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Would execute: apt install unattended-upgrades

ðŸ“– Explanation:
   The unattended-upgrades package automatically installs
   security updates. This is the standard Ubuntu/Debian
   mechanism for keeping systems patched.

Would execute: dpkg-reconfigure unattended-upgrades

ðŸ“– Explanation:
   Enables the service and configures it to run daily.
   By default, only security updates are installed
   automatically, not regular package updates.

Would modify: /etc/apt/apt.conf.d/50unattended-upgrades

ðŸ“– Explanation:
   Configures which updates to install automatically.
   Recommended settings:
   - Security updates: enabled
   - Regular updates: disabled
   - Auto-reboot: disabled (manual control)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## Exporting Dry-Run Output

### Save to File

```bash
cx --dry-run "major system update" > update-plan.txt
```

### JSON Format

```bash
cx --dry-run --format json "install development tools"
```

```json
{
  "mode": "dry-run",
  "operations": [
    {
      "type": "package_install",
      "packages": ["build-essential", "git", "curl"],
      "command": "apt install build-essential git curl"
    }
  ],
  "estimated_changes": {
    "packages_added": 3,
    "disk_space": "150MB"
  }
}
```

### Share for Review

```bash
# Generate shareable summary
cx --dry-run --output summary "production deployment changes" | cx share
```

## Best Practices

### 1. Always Dry-Run First for Production

```bash
# Development - maybe skip dry-run
cx "install debugging tools"

# Production - always dry-run
cx --dry-run "apply configuration changes"
# Review output carefully
cx --execute "apply configuration changes"
```

### 2. Use for Learning

```bash
# Learn what common tasks involve
cx --dry-run "set up a LAMP stack"
cx --dry-run "configure a mail server"
cx --dry-run "install kubernetes"
```

### 3. Validate Understanding

```bash
# Confirm CX Linux understood correctly
cx --dry-run "install postgres but not the graphical tools"
# Check output shows only CLI packages
```

### 4. Document Changes

```bash
# Create audit trail
cx --dry-run "quarterly security hardening" > changes-q1-2024.txt
# Review with team
# Execute with confidence
cx --execute "quarterly security hardening"
```

## Limitations

### What Dry-Run Cannot Show

- Runtime errors (permissions, network issues)
- Exact package versions (may change between dry-run and execute)
- Interactive prompts (some installers require input)
- Side effects of scripts (post-install scripts)

### When to Use Caution

Even after dry-run, be careful with:

```bash
# Data deletion
cx --dry-run "clean up old databases"
# Verify backup exists before execute

# Network changes
cx --dry-run "reconfigure network interfaces"
# Have physical access or out-of-band management

# Kernel updates
cx --dry-run "update kernel"
# Ensure you can recover if boot fails
```

## Related Documentation

- [Rollback & Recovery](/docs/user-guide/rollback-recovery) - Undo changes
- [CLI Commands](/docs/reference/cli-commands) - Full command reference
- [Configuration](/docs/getting-started/configuration) - Set dry-run as default
